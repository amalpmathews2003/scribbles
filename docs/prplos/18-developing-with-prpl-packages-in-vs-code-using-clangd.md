# Developing with prplOS Packages in VS Code using Clangd

When working with **prplOS** packages, the default IntelliSense in VS Code often fails to resolve headers, macros, and includes.  
This guide explains how to configure **Clangd** for precise code navigation, autocomplete, and inline diagnostics using `compile_commands.json` generated by **Bear**.



## 1. Why Clangd?

Clangd provides powerful, compiler-accurate IntelliSense by leveraging the same flags and include paths used during your package’s actual build.  
Unlike the default VS Code C/C++ extension, Clangd understands complex build environments like **prplOS**, **OpenWrt**, and **Yocto**.



## 2. Prerequisites

Make sure you have the following installed:

```bash
sudo apt install clangd bear
```

In VS Code:

 - Install the Clangd extension (llvm-vs-code-extensions.vscode-clangd).
 - Disable IntelliSense from the default Microsoft C/C++ extension to avoid conflicts.


## 3. Generating compile_commands.json with Bear

Every prplOS package compiles with its own Makefile inside the build system.
To capture all compiler flags and include paths, wrap the build command with bear.

For example, if you’re developing the package tr181-bridging, run:

```bash
bear -- make package/tr181-bridging/{clean,compile} V=sc -j$(nproc)
```

This command:

 - Cleans and recompiles the package
 - Logs every compiler invocation
 - Generates compile_commands.json at the root of your prplOS project


## 4. Creating .clangd Configuration

In your project root, create a file named .clangd.
This file tells Clangd where to find the build commands and adjusts flags for compatibility with prplOS’s environment.

Example .clangd:

```yaml
CompileFlags:
  CompilationDatabase: <prplos project root>
  Remove: [-fhonour-copts]
```

Explanation

 - CompilationDatabase → Absolute path where compile_commands.json is located.
 - Remove → Removes problematic flags (like -fhonour-copts) that Clang doesn’t          recognize but appear in prplOS builds.

If your target is built for a specific architecture (e.g. target-x86_64_musl), Clangd will automatically find the corresponding -I include directories from the compilation database.

## 5. Verifying IntelliSense

Once .clangd and compile_commands.json are ready:

 1. Reload VS Code (Ctrl+Shift+P → Reload Window).
 2. Open a .c or .h file from your package, 
  e.g. package/tr181-bridging/src/bridge.c
 3. Check that:
    - Hover tooltips show definitions and types
    - “Go to Definition” and “Find References” work
    - Header includes resolve properly (no more red squiggles!)


## 6. Common Issues

| Issue  | Cause  | Solution  |
|---|---|---|
|Unknown argument warnings   |prplOS uses GCC-only flags   |Add them to the Remove: list in .clangd   |
| No completion in staging_dir header  |Missing include search paths   | Rebuild the package with Bear again so the captured flags include full paths.  |  


## 7. More Configuration (Optional)

If Clangd still fails to resolve some headers or target-specific defines, you can add extra flags manually:

```yaml

CompileFlags:
  CompilationDatabase: <prplos project root>
  Add: [
    -I/prplos/staging_dir/target-x86_64_musl/usr/include,
    -I/prplos/build_dir/target-x86_64_musl/tr181-bridging-v2.8.18/include
  ]
  Remove: [-fhonour-copts, -mindirect-branch=thunk-extern]
```

## 8. Conclusion

By combining Bear and Clangd, you can transform prplOS development in VS Code into a full-featured embedded C IDE — with proper navigation, autocompletion, and error highlighting.
This setup ensures you’re seeing exactly what the compiler sees, no more and no less.